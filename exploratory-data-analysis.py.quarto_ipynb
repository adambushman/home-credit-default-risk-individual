{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Home Credit Default Risk\"\n",
        "subtitle: \"Part 1 | Exploratory Data Analysis | IS 6812\"\n",
        "author: \"Adam Bushman (u6049169)\"\n",
        "date: \"9/10/2024\"\n",
        "format: \n",
        "    html:\n",
        "        css: styles.css\n",
        "        theme: simplex\n",
        "        toc: true\n",
        "        embed-resources: true\n",
        "editor:\n",
        "    render-on-save: true\n",
        "---\n",
        "\n",
        "\n",
        "# Introduction\n",
        "\n",
        "## The Project\n",
        "\n",
        "#### Business Problem\n",
        "\n",
        "Home Credit cares deeply about the population without sufficient credit history and aims to improve inclusion for this underrepresented group by designing prediction models for loan repayment, such that capable borrowers are not denied solely due to absence of credit while protecting against defaults.\n",
        "\n",
        "#### Benefit of a Solution\n",
        "\n",
        "A more accurate prediction model will help Home Credit a) provide lending terms and b) sufficiently balance risk such that financial inclusion is expanded.\n",
        "\n",
        "#### Success Metrics\n",
        "\n",
        "The success of the project will be measured in accurately predicting loan defaults, so that an increase in loan approval rates among this underrepresented group is accompanied by a stable or even reduction in default rates.\n",
        "\n",
        "#### Analytics Approach\n",
        "\n",
        "A supervised machine learning classification approach will be used to predict loan default risk, leveraging alternative data sources such as telco and transactional information, with the target variable being loan repayment.\n",
        "\n",
        "#### Scope\n",
        "\n",
        "The project will deliver a predictive model for assessing loan repayment abilities.\n",
        "\n",
        "#### Details\n",
        "\n",
        "The project will be executed by a team of business analysts, equipped with data processing and modeling skills. The project will feature iterative milestones for data exploration, model development, and evaluation, culminating in a final model by calendar year end.\n",
        "\n",
        "\n",
        "## My Approach\n",
        "\n",
        "For this exploratory data analysis, I plan to use the following languages, APIs, and tools:\n",
        "\n",
        "*   [Quarto](https://quarto.org/): probably \"the\" notebook of choice for the scientific community; built and maintained by Posit, it's flexible, powerful, and beautiful.\n",
        "*   [Python](https://www.python.org/): I usually default to R for analytical tasks so I could use the extra practice in Python.\n",
        "*   [DuckDB](https://duckdb.org/): an in-process analytical database engine. It is extremely fast and features a convenient syntax. It's gathered tremendous steam in the industry, even for analysis tasks.\n",
        "\n",
        "::: {layout=\"[[3,4,4,5]]\" layout-valign=\"center\"}\n",
        "![](https://quarto-dev.github.io/quarto-r/logo.png)\n",
        "\n",
        "![](https://quantumzeitgeist.com/wp-content/uploads/pythoned.png)\n",
        "\n",
        "![](https://duckdb.org/images/logo-dl/DuckDB_Logo.png)\n",
        "::::\n",
        "\n",
        "Within the Python ecosystem I'll use several libraries that will augment the analytical process. These include, but are not limited to:\n",
        "\n",
        "*   [pandas](https://pandas.pydata.org/docs/index.html): probably *the* foundational package for data analysis in Python\n",
        "*   [scikit-learn](https://scikit-learn.org/stable/): a comprehensive API for data science models and workflows\n",
        "*   [statsmodels](https://www.statsmodels.org/stable/index.html): one of the best statistics libraries in Python\n",
        "*   [plotnine](https://plotnine.org/): the {ggplot2} equivalent in Python, bringing \"grammar of graphics\"\n",
        "*   [skimpy](https://pypi.org/project/skimpy/): a neat package that started in R designed to summarize tabular data in a digestible way\n",
        "\n",
        "\n",
        "::: {layout=\"[[8,14,5,5]]\" layout-valign=\"center\"}\n",
        "![](https://numfocus.org/wp-content/uploads/2016/07/pandas-logo-300.png)\n",
        "\n",
        "![](https://miro.medium.com/v2/resize:fit:984/1*OTt5dpD5N4Ru1qn0WNsZ4g.png)\n",
        "\n",
        "![](https://plotnine.org/images/logo-540.png)\n",
        "\n",
        "![](https://docs.ropensci.org/skimr/logo.png)\n",
        "::::\n",
        "\n",
        "# Analysis Preparation\n",
        "\n",
        "## Data Source\n",
        "\n",
        "The data is sourced from [Kaggle](https://www.kaggle.com/competitions/home-credit-default-risk/overview) where [Home Credit](https://www.homecredit.net/) hosted a competitiion back in the summer of 2018. Data was downloaded therefrom on August 20th, 2024 and used concurrently throughout the Capstone course at University of Utah, Fall 2024.\n",
        "\n",
        "\n",
        "## Loading Data\n",
        "\n",
        "We'll start off importing `duckdb`. We'll do much of the data processing work using this powerful SQL engine.\n"
      ],
      "id": "0570baa7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import duckdb"
      ],
      "id": "37aec816",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With access to the API, we can begin to query our data located in files. We need only setup \"relations\" (informing `duckdb` where the files are located).\n"
      ],
      "id": "db608bb0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "# DuckDB relations\n",
        "# These are tables against which we can query using the DuckDB API\n",
        "\n",
        "duckdb.read_csv(\"data/application_test.csv\")\n",
        "duckdb.read_csv(\"data/application_train.csv\")\n",
        "duckdb.read_csv(\"data/bureau_balance.csv\")\n",
        "duckdb.read_csv(\"data/bureau.csv\")\n",
        "duckdb.read_csv(\"data/credit_card_balance.csv\")\n",
        "duckdb.read_csv(\"data/installments_payments.csv\")\n",
        "duckdb.read_csv(\"data/POS_CASH_balance.csv\")\n",
        "duckdb.read_csv(\"data/previous_application.csv\")\n",
        "\n",
        "duckdb.read_csv(\"data/HomeCredit_columns_description.csv\")"
      ],
      "id": "81ff55dd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This approach isn't what you'd call \"conventional\". How are we expecting to work with this data? We'll walk through some use cases quickly to demonstrate how seamless it will actually be.\n",
        "\n",
        "\n",
        "## Working With the Data\n",
        "\n",
        "Straight away, we can interact with these files with plain SQL. For example, with a simple query (below) we can look at the first 10 rows of the `bureau.csv` file.\n"
      ],
      "id": "2893055d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "duckdb.sql(\"SELECT * FROM 'data/bureau.csv' LIMIT 10\").show()"
      ],
      "id": "3cbcda2d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "DuckDB does a nice job styling the output and including helpful details, such as data types.\n",
        "\n",
        "But don't think we're \"stuck\" in the world of SQL for the duration of this analysis; far from it. DuckDB is very adept at refactoring the data for use with the other packages we'll be using. Let's bring in `pandas` and see how this works:\n"
      ],
      "id": "c7f7b949"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd"
      ],
      "id": "dc5e44c5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df = duckdb.sql(\"SELECT * FROM 'data/bureau.csv' LIMIT 10\").fetchdf()\n",
        "\n",
        "type(df)"
      ],
      "id": "3921ef3e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As you can see, we now have a `pandas` data frame. We could run a model with `scikit-learn`, generate a visualization with `plotnine`, or perform complex, custom logic ill-fit for SQL. For now, we'll just select every other column:\n"
      ],
      "id": "d9d66f7e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df_sub = df.loc[:,::2]\n",
        "\n",
        "df_sub.info()"
      ],
      "id": "696547db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "At this point, we may be ready to leverage the speed and efficiency of DuckDB. So we can just switch right back!\n"
      ],
      "id": "d5271484"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "duckdb.sql(\"SELECT * FROM df_sub\").show()"
      ],
      "id": "28afd6a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "There really won't be any issue navigating between the different APIs. In fact, we'll be able to leverage the unique strengths of each of them to best advance our analysis. \n",
        "\n",
        "\n",
        "# Exploration\n",
        "\n",
        "## Skim each dataset\n",
        "\n",
        "We'll start off by getting familiar with each of the data sets. We'll use the `{skimpy}` package for this and do some visualizations.\n",
        "\n",
        "### `application_train.csv`\n",
        "\n",
        "This file is the same as `application_test.csv` except that it features the target variable. We'll start with the columns:\n"
      ],
      "id": "1110dba7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "duckdb.sql(\"\"\"\n",
        "    SELECT *\n",
        "    FROM 'data/HomeCredit_columns_description.csv'\n",
        "\"\"\")"
      ],
      "id": "57aad5ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "scrolling-y"
      },
      "source": [
        "from skimpy import skim\n",
        "\n",
        "app_train_df = (\n",
        "    duckdb                                                 # Use DuckDB's query engine\n",
        "    .sql(\"SELECT * FROM 'data/application_train.csv'\")     # Read the file\n",
        "    .fetchdf()                                             # Convert to a pandas dataframe\n",
        ")\n",
        "\n",
        "skim(app_train_df)                                         # \"Skim\" the data set"
      ],
      "id": "19872989",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is a LARGE data set. Let's break down some of the observations we can glean from the summary:\n",
        "\n",
        "#### Data Types\n",
        "\n",
        "*   There's several variables casted as numeric that should be categorical\n",
        "    *   Any variables with `FLAG_` prefixes: ~32 columns\n",
        "        *   Examples: `FLAG_MOBIL`, `FLAG_DOCUMENT_#`, ...\n",
        "    *   Other variables treated as flags but not specified in the name: ~6 columns\n",
        "        *   Examples: `REG_REGION_NOT_LIVE_REGION`, `LIVE_CITY_NOT_WORK_CITY`, ...\n",
        "    *   `REGION_RATING_` variables that are ordinal classificaitons\n",
        "*   Many variables of type `string` could be candidates for categorical depending on count of unique values\n",
        "    *   Examples: `NAME_CONTRACT_TYPE`, `ORGANIZATION_TYPE`\n",
        "*   Some variables casted as `string` but may need to be numeric\n",
        "    *   Any with `_MODE` suffix\n",
        "\n",
        "#### Missing Data\n",
        "\n",
        "*   `EXT_SOURCE_#` these are scores ingested from third parties\n",
        "    *   Understandably sparse; not every client would be represented in third-party systems\n",
        "*   Fields including `APARTMENT_`, `BASEMENT_`, `ELEVATOR_`, etc., all relate to the client's current dwelling.\n",
        "    *   43 of the file's 122 columns relate to the client's dwelling\n",
        "    *   These are very sparse, about ~50% complete. These fields represent most of the missing data\n",
        "    *   Presumably, the lender was unable to collect such detail for every client\n",
        "*   `OBS_##_SOCIAL_CIRCLE` and `DEF_##_SOCIAL_CIRCLE` relate to default rates on observation ## days past due\n",
        "    *   This is a count that's heavily skewed to the right\n",
        "    *   <1% of observations have these fields as missing\n",
        "*   `AMT_REQ_CREDIT_BUREAU_XX` are fields measure the number of credit inqueries in XX timeframe\n",
        "    *   This data set is geared around users without sufficient credit history so makes sense this is missing\n",
        "    *   ~13% of the data is missing\n",
        "*   `OCCUPATION_TYPE` refers to the type of job the user has\n",
        "    *   Missing for virtually 1/3 clients\n",
        "    *   `ORGANIZATION_TYPE`, however, is not missing so we do retain some attribute relative to their work\n",
        "    *   Perhaps in combination with `NAME_EDUCATION_TYPE` there's predictive power\n",
        "\n",
        "#### Distribution\n",
        "\n",
        "*   All dwelling related variables have been *normalized* based on description column descriptions file\n",
        "    *   Checking the histograms to the far right, this appears to be accurate\n",
        "*   There's a couple variables with skewed distributions\n",
        "    *   `DAYS_REGISTRATION`: skewed right\n",
        "    *   `DAYS_LAST_PHONE_CHANGE`: skewed right\n",
        "\n",
        "#### Potential feature engineering\n",
        "\n",
        "*   Dimensionality reduction\n",
        "    *   `FLAG_DOCUMENT_#` fields could potentially be summarized a few ways;\n",
        "        *   % of documents completed\n",
        "        *   Finding principal components\n",
        "        *   Maybe only certain documents matter\n",
        "    *   There's many measures of central tendency for dwelling (avg, mode, median)\n",
        "        *   Likely not all for each perspective is needed\n",
        "\n",
        "### `bureau.csv`\n",
        "\n",
        "This file is the same as `application_test.csv` except that it features the target variable.\n"
      ],
      "id": "e1c9b7a3"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "scrolling-y"
      },
      "source": [
        "from skimpy import skim\n",
        "\n",
        "app_train_df = (\n",
        "    duckdb                                                 # Use DuckDB's query engine\n",
        "    .sql(\"SELECT * FROM 'data/application_train.csv'\")     # Read the file\n",
        "    .fetchdf()                                             # Convert to a pandas dataframe\n",
        ")\n",
        "\n",
        "skim(app_train_df)                                         # \"Skim\" the data set"
      ],
      "id": "ac8b196a",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\adamb\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}